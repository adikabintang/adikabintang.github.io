<h1 id="understanding-http2-the-basics">Understanding HTTP2, The Basics</h1>
<p>This note is taken from here:</p>
<ul>
  <li>https://developers.google.com/web/fundamentals/performance/http2/</li>
  <li>http://undertow.io/blog/2015/04/27/An-in-depth-overview-of-HTTP2.html</li>
  <li>https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/</li>
  <li>see on section “Concern about performance”: https://medium.com/pyspa/how-to-use-golang-1-8s-http-2-server-push-api-4522a45a2eb9</li>
  <li>another load testing tool: https://github.com/tsenart/vegeta how to use it: https://github.com/golang/go/issues/18404
    <h2 id="design-goal">Design Goal</h2>
    <p>HTTP2 focuses more on performance.</p>
  </li>
</ul>

<h2 id="whats-new">What’s New</h2>
<h3 id="binary-framing-layer">Binary Framing Layer</h3>
<p>According to <a href="https://developer.ibm.com/articles/wa-http2-under-the-hood/#binary-protocol">[1]</a>, it means the same with “HTTP2 as a binary protocol”.</p>

<p>Now, what is binary protocol?</p>

<p>Consider this HTTP1.1 request and response:</p>

<p>Request</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET
Host: google.com
</code></pre></div></div>

<p>Response:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Content-Length: 6969  // look at this, hint (1)
</code></pre></div></div>

<p>HTTP1.1 is a text protocol. It means that the number 6969 in Content-Length is represented in string ([‘6’, ‘9’, ‘6’, ‘9’]). In contrast, if it’s a binary protocol, that 6969 would be presented as 0d6969 (the number 6969 in decimal format). Here are good explanations from stackoverflow <a href="https://stackoverflow.com/questions/2645009/binary-protocols-v-text-protocols">[1]</a> <a href="https://stackoverflow.com/questions/2364581/binary-vs-text-protocols">[2]</a>.</p>

<p><img src="https://developers.google.com/web/fundamentals/performance/http2/images/binary_framing_layer01.svg" alt="HTTP2 binary protocol" /></p>

<h3 id="streams-messages-and-frames">Streams, messages, and frames</h3>
<p>HTTP2 terminology:</p>
<ul>
  <li><em>Stream</em>: A bidirectional flow of bytes within an established connection.</li>
  <li><em>Message</em>: A complete sequence of frames that map to a logical request or response message.</li>
  <li><em>Frame</em>: The smallest unit of communication in HTTP2. Think of the term “TCP frame”, now think of “HTTP2 frame”. Huh?</li>
</ul>

<p>The relation of these terms:</p>
<ul>
  <li>All communication is performed over a single TCP connection that can carry any number of streams. Yes, multiplexed.</li>
  <li>Each stream has a <em>unique identifier</em> and <em>optional priority identifier</em> that is used to carry bidirectional messages.</li>
  <li>Each HTTP2 message consists of one or more HTTP2 frames</li>
  <li>Frames from different streams may be interleaved and then reassembled via the embedded stream identifier in the header of each frame.
<img src="https://developers.google.com/web/fundamentals/performance/http2/images/streams_messages_frames01.svg" alt="HTTP2 streams" /></li>
</ul>

<h3 id="request-and-response-multiplexing">Request and response multiplexing</h3>
<p>In HTTP1.1, there is no multiplexing. As a result, each HTTP1.1 request is done by one TCP connection <a href="https://hpbn.co/http1x/#using-multiple-tcp-connections">[3]</a>. Most browsers are able to open 6 TCP connections at a time.</p>

<p>The picture below shows that HTTP2 can break down HTTP2 message into independent frames, interleave them, and reassemble them on the other ends.</p>

<p><img src="https://developers.google.com/web/fundamentals/performance/http2/images/multiplexing01.svg" alt="Multiplexing" /></p>

<p>The picture also shows that on a single connection, there are 3 streams: stream 1, stream 3, and stream 5. This multiplexing brings some advantages:</p>
<ul>
  <li>Interleave multiple requests and response in parallel</li>
  <li>Use a single connection to deliver multiple requests and response in parallel</li>
  <li>Deliver lower page load times by eliminating unnecessary latency and improving utilization of available network capacity</li>
</ul>

<h3 id="stream-prioritization">Stream prioritization</h3>
<p>Once an HTTP message is split into many frames, the frames from multiple streams is multiplexed, HTTP2 has mechanism to interleave these streams.</p>

<p>How?</p>
<ul>
  <li>Each stream may be assigned an integer weight between 1 and 256</li>
  <li>Each stream may be given an explicit dependency on another stream</li>
</ul>

<p>Huh? OK. Example:</p>

<p><img src="https://developers.google.com/web/fundamentals/performance/http2/images/stream_prioritization01.svg" alt="Stream" /></p>

<p>Focus on the first two from the left:</p>
<ol>
  <li>A and B are said to be dependent on the implicit “root stream”. A does not depend on B. A has weight 12, B has 4. Therefore, stream A should receive 12/(12+4) of available resource. B should receive 4/(12+4) of available resource</li>
  <li>C depends on D. C should receive full available resource. Weight does not matter here since C should be processed after D.</li>
</ol>

<p>Stream dependencies and weights express a transport reference, not a requirement. Therefore, it does not guarantee the transmission order.</p>

<h3 id="flow-control">Flow Control</h3>
<p>Let’s begin with “what’s TCP flow control”.</p>
<h4 id="tcp-flow-control">TCP Flow Control</h4>
<p>TCP flow control ensures that a sender is not overwhelming the receiver. In distributed systems (remember fluentd-elasticsearch, ha?), it’s to avoid <em>back pressure</em>.</p>

<p>How it works?
The receiver will advertise its receive window (receive window: the spare room in the receive buffer).</p>

<p><img src="https://www.brianstorti.com/assets/images/tcp-flow-control/rwnd.png" alt="window" />
Source: <a href="https://www.brianstorti.com/tcp-flow-control/">brianstorti.com</a></p>

<h4 id="http2-flow-control">HTTP/2 Flow Control</h4>
<p>HTTP2 provides a set of building blocks to allow client and server to implement their own stream- and connection-level flow control:</p>
<ul>
  <li>Flow control is directional. Each receiver may choose to set any window size that it desires for each stream and the entire connection.</li>
  <li>Flow control is credit-based. Receiver advertises its initial connection and stream flow control window (in bytes), which is reduced whenever the sender emits a DATA frame and incremented via a WINDOW_UPDATE frame sent by the receiver.</li>
  <li>Flow control cannot be disabled.</li>
  <li>Flow control is hop-by-hop, not end-to-end.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If HTTP2 sits on top of TCP, and TCP has TCP flow control, why HTTP2 needs to implement a new one?
Answer: https://hpbn.co/http2/#flow-control
HTTP2 streams are multiplexed in a single TCP connection. It makes HTTP2 need to have flow control mechanism in application layer level (we cannot have control of TCP/layer 3 flow control on application layer level) and TCP flow control is not granular enough for HTTP2 frames.
</code></pre></div></div>

<h3 id="server-push">Server Push</h3>
<p>HTTP2 server push in one sentence:</p>

<blockquote>
  <p>The ability of the server to send multiple responses for a single client request.</p>
</blockquote>

<p><img src="https://developers.google.com/web/fundamentals/performance/http2/images/push01.svg" alt="server push" /></p>

<p>Push resources can be:</p>
<ul>
  <li>Cached by the client</li>
  <li>Reused across different pages</li>
  <li>Multiplexed alongside other resources</li>
  <li>Prioritized by the server</li>
  <li>Declined by the client</li>
</ul>

<h4 id="how-push_promise">How? PUSH_PROMISE</h4>
<p>All server push streams are initiated via <code class="highlighter-rouge">PUSH_PROMISE</code> fames, which signal the server’s intent to push the described resources to the client. <code class="highlighter-rouge">PUSH_PROMISE</code> needs to delivered ahead of the response data that requests the pushed resources.</p>

<p>Pushed resources must obey the same-origin policy.</p>

<h3 id="header-compression">Header compression</h3>
<p>The header is compressed with HPACK algorithm. HPACK uses two techniques:</p>
<ul>
  <li>The transmitted header fields to be encoded via a static Huffman code, which reduces their individual transfer size.</li>
  <li>Both client and server maintain and update an indexed list of previously seen header fields (shared compression context), which is used as a reference to efficiently encode previously transmitted values.</li>
</ul>

<p><img src="https://developers.google.com/web/fundamentals/performance/http2/images/header_compression01.svg" alt="hpack" /></p>

