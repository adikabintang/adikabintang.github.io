<p>Tutorial: https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285</p>

<p>For testing: https://regex101.com/r/cO8lqs/11</p>

<h1 id="basic">Basic</h1>

<h2 id="anchors--and-">Anchors: ^ and $</h2>
<h3 id="start">^start</h3>
<p><code class="highlighter-rouge">^something</code> -&gt; matches string <strong>starting</strong> with “something”.</p>

<p>Example</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>^asu
will select "asu" in
asu koe mangan rumput
</code></pre></div></div>

<h3 id="end">end$</h3>
<p><code class="highlighter-rouge">lastword$</code> -&gt; matches string <strong>ending</strong> with “lastword”.</p>

<p>Example:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>govan$
will match "govan" in
guthrie govan

but not in
guthrie govan plays the guitar
</code></pre></div></div>

<h3 id="exact_match">^exact_match$</h3>
<p><code class="highlighter-rouge">^exact$</code> -&gt; exact string match</p>

<h3 id="matches-that-contains-word">matches that contains “word”</h3>
<p>Example</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eek

will match
oi eek lu bau
</code></pre></div></div>

<h2 id="quantifiers----and-">Quantifiers: * + ? and {}</h2>

<p><code class="highlighter-rouge">abc*</code>   matches a string that has <strong>ab followed by 0 or more c</strong></p>

<p><code class="highlighter-rouge">abc+</code>   matches a string that has <strong>ab followed by 1 or more c</strong></p>

<p><code class="highlighter-rouge">abc?</code>   matches a string that has <strong>ab followed by 0 or 1 c</strong></p>

<p><code class="highlighter-rouge">abc{2}</code>   matches a string that has <strong>ab followed by 2 c</strong></p>

<p><code class="highlighter-rouge">abc{2,}</code>  matches a string that has <strong>ab followed by 2 or more c</strong></p>

<p><code class="highlighter-rouge">abc{2,5}</code> matches a string that has <strong>ab followed by 2 up to 5 c</strong></p>

<p><code class="highlighter-rouge">a(bc)*</code>   matches a string that has <strong>a followed by 0 or more copies of bc</strong></p>

<p><code class="highlighter-rouge">a(bc){2,5}</code> matches a string that has <strong>a followed by 2 up to 5 copies of bc</strong></p>

<h2 id="or-operator--and-">OR operator: | and []</h2>

<p><code class="highlighter-rouge">a(b|c)</code>   matches a string that has <strong>a followed by b or c</strong></p>

<p><code class="highlighter-rouge">a[bc]</code>    same as <code class="highlighter-rouge">a(b|c)</code></p>

<h2 id="character-classes-d-w-s-and--read-dot">Character classes: \d, \w, \s, and . (read: dot)</h2>

<p><code class="highlighter-rouge">\d</code>   matches a <strong>single digit</strong>. for example, it will match 2, 4, 2 in “aob a2b a42c” (see, it matches a <em>single</em> digit). Negation: <code class="highlighter-rouge">\D</code> (matches a single non-digit character)</p>

<p><code class="highlighter-rouge">\w</code>   matches a <strong>word character (alphanumeric and _)</strong>. Negation: <code class="highlighter-rouge">\W</code> (matches a non-word character)</p>

<p><code class="highlighter-rouge">\s</code>   matches a <strong>space</strong> (including tabs and line breaks). Negation: <code class="highlighter-rouge">\S</code></p>

<p><code class="highlighter-rouge">.</code>    matches any character</p>

<h2 id="how-to-escape-the-character">How to escape the character</h2>
<p>using <code class="highlighter-rouge">\</code>. For example, to match the character <code class="highlighter-rouge">$</code> in a string, we would use <code class="highlighter-rouge">\$</code>.</p>

<h2 id="flags">Flags</h2>
<p>A regex usually comes with the form like <code class="highlighter-rouge">/abc/</code>, where the search pattern is delimited by two <code class="highlighter-rouge">/</code> characters. At the and of <code class="highlighter-rouge">/</code> we can specify a flag with these values:</p>
<ul>
  <li><strong>i</strong> (case insensitive) for example, <code class="highlighter-rouge">/aBc/</code> would match <code class="highlighter-rouge">Abc</code></li>
  <li><strong>g</strong> (global) does not return after the first match, restarting the subsequent searches from the end of the previous match</li>
  <li><strong>m</strong> (multi-line) when enabled <code class="highlighter-rouge">^</code> and <code class="highlighter-rouge">$</code> will match the start and end of a line, instead of the whole string.</li>
</ul>

<h1 id="intermediate">Intermediate</h1>
<h2 id="grouping-and-capturing">Grouping and capturing</h2>

<p><code class="highlighter-rouge">a(bc)</code>   paretheses create a <strong>capturing group with value bc</strong></p>

<p>What?? The point is, <em>it creates grouping</em>.</p>

<p>For example, <code class="highlighter-rouge">a(bc)(op)</code>:</p>
<ul>
  <li>mathces character <code class="highlighter-rouge">a</code></li>
  <li>1st capturing group: matches character <code class="highlighter-rouge">bc</code></li>
  <li>2nd capturing group: matches character <code class="highlighter-rouge">op</code></li>
</ul>

<p>Explanation with example:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regex: a(bc)
string: abc bca abcd ab abcop
result:
match 1
full match (group 0): abc (pos: 0-3)
group 1: bc (pos: 1-3)

match 2
full match (group 0): abc (pos: 8-11 or see abc in abcd)
group 1: bc (pos: 9-11)

match 3
full match (group 0): abc (pos: 16-19 or see abc in abcdop)
group 1: bc (pos: 17-19)

------------------------------
regex: a(bc)op
string: abc bca abcd ab abcop
result:
match 1
full match (group 0): abcop
group 1: bc  (in abcop)

------------------------------
regex: a(bc)(op)
string: abc bca abcd ab abcop
result:
match 1
full match (group 0): abcop
group 1: bc
group 2: op
</code></pre></div></div>

<p><code class="highlighter-rouge">a(?:bc)*</code>   using <code class="highlighter-rouge">?:</code> we <strong>disable the capturing group</strong>. <code class="highlighter-rouge">:?</code> is called <em>non-capturing group</em>.</p>

<p>Example:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string: abc ac acb aob a2b a42c A87d

regex: a(?:bc)
result:
full match: abc

regex: a(?:bc)*
full match: abc
full match: a
full match: a
full match: a
full match: a
full match: a
why? because * means matches between 0 and unlimited times bc
</code></pre></div></div>

<p><code class="highlighter-rouge">a(?&lt;foo&gt;bc)</code> using <code class="highlighter-rouge">?&lt;foo&gt;</code> we put a name to the group.
Example:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string: abc ac acb aob a2b a42c A87d
regex: a(?&lt;foo&gt;bc)
result:
full match: abc
Group `foo`: bc
</code></pre></div></div>

<h2 id="bracket-expressions">Bracket expressions</h2>
<p>Inside bracket <code class="highlighter-rouge">[]</code>, special characters lose their power and we will not apply the escape character rule.</p>

<p><code class="highlighter-rouge">[abc]</code>   matches a string that has <strong>either a or b or c</strong> (same as <code class="highlighter-rouge">a|b|c</code>).</p>

<p><code class="highlighter-rouge">[a-c]</code>   same as previous</p>

<p>Example:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string: abc ac acb aob
regex: [abc]
result:
match 1: a
match 2: b
match 3: c
match 4: a
match 5: c
match 6: a
match 7: c
match 8: b
match 9: a
match 10: b
</code></pre></div></div>

<p><code class="highlighter-rouge">[a-fA-F-0-9]</code>  matches a string that represents a single hexadecimal digit, case insensitively.</p>

<p><code class="highlighter-rouge">[0-9]%</code>   matches a string that has a character from 0 to 9 before % sign.</p>

<p><code class="highlighter-rouge">[^a-zA-Z]</code>  a string that has <strong>not a letter from a to z or from A to Z</strong>. In this case the ^ is used as a <strong>negation of the expression</strong>.
Example:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string: sold for $1
regex: [^a-zA-Z]
match 1:  (space)
match 2:  (space)
match 3: $
match 4: 1
</code></pre></div></div>

<h2 id="greedy-and-lazy-match">Greedy and Lazy match</h2>
<p>The quantifiers <code class="highlighter-rouge">* + {}</code> are greedy operators, so they expand the match as far as they can through the provided text.</p>

<p>For example,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string: This is a &lt;div&gt; simple div&lt;/div&gt; test
regex: &lt;.+&gt;
match: &lt;div&gt;simple div&lt;/div&gt;
</code></pre></div></div>

<p>To make it lazy, we use <code class="highlighter-rouge">?</code>. For instance,
<code class="highlighter-rouge">&lt;.+?&gt;</code>  matches any character one or more times inclyded inside &lt;&gt;, expanding as needed. For example:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string: This is a &lt;div&gt; simple div&lt;/div&gt; test
regex: &lt;.+?&gt;
match 1: &lt;div&gt;
match 2: &lt;/div&gt;

string: This is&lt;&gt; a &lt;div&gt; simple div&lt;/div&gt; test
regex: &lt;.+?&gt;
match 1: &lt;&gt; a &lt;div&gt;
match 2: &lt;/div&gt;
</code></pre></div></div>

<p>To get a stricter regex matches tag inside &lt;&gt;, we can use:</p>

<p><code class="highlighter-rouge">&lt;[^&lt;&gt;]+&gt;</code> matches at least one character inside &lt;&gt; except (except symbol: ^) the character &lt; or &gt;. Example:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string: This is&lt;&gt; a &lt;div&gt; simple div&lt;/div&gt; test
regex: &lt;.+?&gt;
match 1: &lt;div&gt;
match 2: &lt;/div&gt;
</code></pre></div></div>

<h1 id="advance">Advance</h1>
<h2 id="boundaries-b-and-b">Boundaries: \b and \B</h2>

<p><code class="highlighter-rouge">\babc\b</code>   matches a <strong>whole words only</strong>.</p>

<p>The negation of <code class="highlighter-rouge">\b</code> is <code class="highlighter-rouge">\B</code>.</p>

<p><code class="highlighter-rouge">\Babc\B</code>   matches only if the pattern is <strong>fully surrounded by word</strong> characters.</p>

<p>Example:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string: ab abc abcc babc
regex: \babc\b
match: abc (pos: 3-6)

string: ab abc abcc babcd
regex: \Babc\B
match: abc (pos: 13-16, abc in babcd)
</code></pre></div></div>

<h2 id="back-references-1">Back-references: \1</h2>
<p><code class="highlighter-rouge">([abc])\1</code>  using \1 it matches <strong>the same</strong> text <strong>that was most recently matched by the first capturing group</strong>. <a href="https://regex101.com/r/cO8lqs/14">try</a></p>

<p><code class="highlighter-rouge">([abc])([de])\2\1</code>   we can use \2 (and \3, \4, etc) to identify <strong>the same</strong> text that <strong>was matched by the second (third, forth, etc) capturing group</strong>. <a href="https://regex101.com/r/cO8lqs/15">try</a></p>

<p><code class="highlighter-rouge">(?&lt;foo&gt;[abc])\k&lt;foo&gt;</code>  we put the name foo to the group and we reference it later <code class="highlighter-rouge">(\k&lt;foo&gt;)</code>. The result is the same of the first regex (<code class="highlighter-rouge">([abc])\1</code>, but here the group has name <code class="highlighter-rouge">foo</code>). <a href="https://regex101.com/r/cO8lqs/16">try</a></p>

<h2 id="look-ahead-and-look-behind--and-">Look-ahead and Look-behind: (?=) and (?&lt;=)</h2>
<p><code class="highlighter-rouge">d(?=r)</code>  matches <code class="highlighter-rouge">d</code> and only if is <strong>followed by r, but r will not be part of the overal regex match</strong>. <a href="https://regex101.com/r/cO8lqs/18">try</a></p>

<p><code class="highlighter-rouge">(?&lt;=r)d</code>   matches <code class="highlighter-rouge">d</code> only if <strong>preceded by r, but r will not be part of the overall regex match</strong>. <a href="https://regex101.com/r/cO8lqs/19">try</a></p>

<p><strong>The negation:</strong>
<code class="highlighter-rouge">d(?!r)</code>   matches <code class="highlighter-rouge">d</code> only if not followed by r.</p>

<p><code class="highlighter-rouge">(?&lt;!r)d</code>   matches <code class="highlighter-rouge">d</code> only if it is not preceded by r.</p>
